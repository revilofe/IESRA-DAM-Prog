<section>
    <section data-markdown>
        # Unidad 3
        ## Introducción a la programación orientada a objetos
    </section>
    <!--
        Bloques de diapositivas
    -->
    <section data-markdown>
        ## Resultado de Aprendizaje 2
        > Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programación orientada a objetos.
    </section>
    <section data-markdown>
        ## Criterios de evaluación
        - a) Se han identificado los fundamentos de la programación orientada a objetos.
        - b) Se han escrito programas simples.
        - c) Se han instanciado objetos a partir de clases predefinidas.
        - d) Se han utilizado métodos y propiedades de los objetos.
        - e) Se han escrito llamadas a métodos estáticos.
        - f) Se han utilizado parámetros en la llamada a métodos.
        - g) Se han incorporado y utilizado librerías de objetos.
        - h) Se han utilizado constructores.
        - i) Se ha utilizado el entorno integrado de desarrollo en la creación y compilación de programas simples
    </section>

    <section data-markdown>
        ## Contenidos mínimos:
        **Utilización de objetos:**
        - Características de los objetos.
        - Instanciación de objetos.
        - Utilización de métodos.
        - Utilización de propiedades.
        - Utilización de métodos estáticos.
        - Librerías de objetos. Inclusión y uso.
        - Constructores.
        - Destrucción de objetos y liberación de memoria.
        - Entornos de desarrollo para programación orientada a objetos.
            - Entornos específicos.
            - Plugins de integración en entornos genéricos.
    </section>
    <section data-markdown>
        *********************
    </section>
    <section data-markdown>
        ## Programación OO (RA2.a)
        - La [**Programación Orientada a Objetos (POO)**](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos):  viene a cambiar la forma de programar. Los objetos se utilizan como metáfora para emular las entidades reales del negocio a modelar.
        - Está basada en varias técnicas como: herencia, cohesión, abstracción, polimorfismo, acoplamiento y encapsulamiento.

        [mapa mental](https://www.mindomo.com/no/mindmap/programacion-orientada-a-objetos-e256c81f6f8fd0e0654dd70bf05ff657)
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        - [**Clases:**](https://github.com/revilofe/_kotlin_#clases) Una plantilla para la creación de objetos de datos según un modelo predefinido.
        - Ej: Persona, Animal, Coche
        - Las [**clases**](shorturl.at/ikBI9) tienen los siguientes componentes siguientes características, son:
            - **Atributos/campos**: también variables de instancia, contienen la información de los futuros objetos. Normalmente privadas al objeto.
            - **Métodos**: implementan la funcionalidad asociada al objeto, son funciones. Pueden acceder a las variables de instancia de la clase directamente.
            - Cuando se desea realizar una acción sobre un objeto, se dice que se le manda un **mensaje** invocando a un método que realizará la acción.
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        ![](images/clase.png)
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        - **Objetos**: Una instancia de la clase, es decir una concreción. Es un ejemplo de esa clase.
        - Ej: Eduardo, mi perro Tobi, mi coche Ford Fiesta rojo.
        - Los [**objetos**](shorturl.at/gyACE) tienen las siguientes características, son:
            - **Identidad**: Lo identifica del resto.
            - **Comportamiento**: Relacionadlo con su funcionalidad, determina las operaciones que se pueden realizar y con las que responde a los mensajes.
            - **Estado**: Conjunto de atributos y sus valores en un momento determinado.
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        ![](images/objetos.png)
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        ![](images/homerpoo.png)
    </section>
    <section data-markdown>
        ## En kotlin, clases predefinidas  (RA2.c)
        - En Kotlin, todo es un objeto en el sentido de que podemos llamar funciones y propiedades de miembro en cualquier variable.
            - `Int` es una clase y `1` es un objeto de la clase `Int`.

        - Clases predefinidas en Kotlin
            - https://kotlinlang.org/api/latest/jvm/stdlib/alltypes/
        - ***Actividad 3.1:*** Crea un programa en el que uses algún método de la clase Int y sacalo por consola. Haz lo mismo con otra Clase p.Ej: Pair,
    </section>
    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        - Las clases son los bloques de construcción principales de cualquier lenguaje de programación orientado a objetos.
        - Las clases son esencialmente tipos personalizados: un grupo de variables y métodos unidos en una estructura coherente.
        - Para definir una clase se usa la palabra clave `class`.

        ~~~
            class Perro { ... }
            class Empty // Clase vacia
        ~~~
    </section>
    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        En kotlin, las clases pueden contener:
        - Constructores y bloques `init`
        - Métodos(Funciones)
        - Atributos
    </section>

    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        - Una clase en Kotlin puede tener un [constructor primario](https://github.com/revilofe/_kotlin_#constructor-primario) y uno o más [constructores secundarios](https://github.com/revilofe/_kotlin_#constructor-secundario).
            - **Primario**: forma parte del encabezado de la clase.
            - Por defecto, todos los constructores son públicos. Visible donde sea visible la clase.
            - Si el constructor principal no tiene anotaciones o modificadores de visibilidad, la palabra clave `constructor` se puede omitir.
            - Este constructor no tiene código, pero se coloca en bloques de inicialización con la palabra clave `init`
    </section>

    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        - Una clase en Kotlin puede tener un [constructor primario](https://github.com/revilofe/_kotlin_#constructor-primario) y uno o más [constructores secundarios](https://github.com/revilofe/_kotlin_#constructor-secundario).

        Ej. constructor primario.

        ~~~
        class Persona constructor(nombre: String) { ... } //Crea una clase
        p = Persona("Jose")  //Instancia un objeto de la clase Persona,
        ~~~
    </section>

    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        - ***Actividad 3.2:*** Copia y ejecuta el siguiente código. ¿Cómo se crea una instancia de la clase? Create una instancia de clase InitOrderDemo ¿Cuál es el orden de ejecución del código?

        ~~~
        class InitOrderDemo(name: String) {
            val firstProperty = "First property: $name"
            init
            {   println("First initializer block that prints ${name}")
            }

            val secondProperty = "Second property: ${name.length}"
            init
            {   println("Second initializer block that prints ${name.length}")
            }
        }
        ~~~
    </section>
    <section data-markdown>
        ## Clases y constructores e init (RA2.h, RA2.b)
        - Dentro de los bloques `init` puedes usar la palabra `required` para validar las propiedades o parámetros.

        ~~~
        class Persona(Nombre: String)
        {
            init
            {   require(nombre.trim().length > 0) { "Argumento nombre inválido." }
            }
        }
        ~~~

        - ***Actividad 3.3:*** Crea una clase coche, que se inicializa con su marca. Ademas y compruebe mediante `require` en el bloque `init` que el argumento marca no es nulo.
    </section>
    <section data-markdown>
        ## Clases y constructores y propiedades (RA2.d)
        - Las [variables de  instancia o propiedades](https://github.com/revilofe/_kotlin_#propiedades) pueden definirse en el constructor o en el cuerpo de la clase. Si en el constructor principal usamos:
            - val: Se crearán métodos getter
            - var: Se crearán métodos [getter y setter](https://github.com/revilofe/_kotlin_#getters-and-setters)
        - También puedes definirlos tu :

        ~~~
        var stringRepresentation: String
            get() = this.toString()
            // parses the string and assigns values to other properties
            set(value)
            {   setDataFromString(value)
            }
        ~~~
    </section>
    <section data-markdown>
        ## Clases y constructores y propiedades (RA2.d)
        - Existe un [campo de respaldo](https://github.com/revilofe/_kotlin_#backing-fields) `field`, que solo tiene sentido dentro de getter o setter.

        ~~~
        var selectedColor: Int = someDefaultValue
            get() = selectedColor
            set(value) { this.selectedColor = value
                doSomething()
            }
        // Código correcto
        var selectedColor: Int = someDefaultValue
            get() = field
            set(value) { field = value
                doSomething()
            }
        ~~~
    </section>
    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        - Una clase en Kotlin puede tener un [constructor primario](https://github.com/revilofe/_kotlin_#constructor-primario) y uno o más [constructores secundarios](https://github.com/revilofe/_kotlin_#constructor-secundario).
            - **Secundario**: puede tener uno o varios, y se definen con la palabra clave `constructor`
            - Este constructor tiene código, pero se coloca en bloques de inicialización con la palabra clave `init`
            - Si la clase tiene un constructor primario, el secundario debe delegar en el constructor primario, ya sea directamente o indirectamente usando la palabra clave 'this':

    </section>
    <section data-markdown>
        ## Clases y constructores   (RA2.h)
        - Una clase en Kotlin puede tener un [constructor primario](https://github.com/revilofe/_kotlin_#constructor-primario) y uno o más [constructores secundarios](https://github.com/revilofe/_kotlin_#constructor-secundario).

        Ej. constructor secundario.

        ~~~
        class Persona(Nombre: String){
            // Constructor secundario, Usamos 'this' para invocar al primario
            constructor(nombre: String, parent: Person) : this(nombre)
            {   parent.children.add(this)
            }
        }
        ~~~
    </section>
    <section data-markdown>
        ## Clases y constructores (RA2.h, RA2.b)
        - ***Actividad 3.4:*** Un coche tiene:
        - como atributos en su constructor secundario: Marca, Modelo, velocidadMax y color (por defecto blanco)
        - Crea una clase coche, y compruebe mediante `require` en el bloque `init` que
        - la velocidad es mayor que 10 y menor que 250.
    </section>
    <section data-markdown>
        ## Clases y propiedades (RA2.d)
        - En Kotlin, los campos de la clase se llaman **propiedades** o **variables de instancia**
        - Las propiedades de una clase pueden declararse como mutables (var), o de inmutables o de sólo lectura (val)
        - Las propiedades son otros objetos que cualifican al objeto y se acceden a través del `.` y el nombre de la propiedad

        ~~~Kt
        class Persona {
            var ciudad: String
            var fechanacimiento: Date
            var codigoPostal: String
        }
        p=Persona()
        println("La ciudad de la persona es es:$p.ciudad")
        ~~~
    </section>
    <section data-markdown>
        ## Clases y métodos (RA2.d)
        - En Kotlin, las funciones definidas dentro de una clase se llaman funciones miembro o métodos de instancia.
        ~~~
        class Persona {
            var ciudad: String
            fun soyDe():String = "Soy de $ciudad"
        }
        p=Persona()
        println("De donde eres? La ciudad de la persona es es:$p.soyDe()")
        ~~~
    </section>
    <section data-markdown>
        ## Clases y métodos (RA2.b)
        - ***Actividad 3.5:*** Un coche tiene:
            - como atributos: Marca, Modelo, #gasolina, Color (defecto blanco), #tanque, #variacionVelocidad=5, #velocidadMax, #factorGasto (Double), #numeroMarchas
            - como acciones: encender, apagar, iniciar, parar, acelerar, frenar, incrementaMarcha, decrementaMarcha, llenarTanque
            - además podremos preguntarle por la descripción del coche, el estado, la marcha actual, la velocidad actual
            - Crea una clase coche, y compruebe mediante `require` en el bloque `init` que
            - el argumento marca no es nulo.
            - la velocidad es mayor que 10 y menor que 250.
            - cualquier otro valor que cras conveniente.
    </section>
    <section data-markdown>
        ## Métodos (RA2.b)
        - ***Actividad 3.5:*** Un coche tiene (continuación)
            - encender: Devuelve true si enciende. Solo enciende si no esta encendido, NO tiene marcha metida y tiene gasolina
            - apagar: Vuelve al estado inicial ¿necesitas alguna propiedad o método adicional?
            - iniciar: Solo inicia si esta encendido (No andando). El proceso será establecer marcha 1 y acelerar.
    </section>
    <section data-markdown>
        ## Métodos (RA2.b)
        - ***Actividad 3.5:*** Un coche tiene (continuación)
            - acelerar: Devuelve la velocidad a la que va, solo acelera (+variacionVelocidad) si tiene gasolina, si no envía mensaje y llama al método parar. No puede superar velocidadMax.
                - ¿cuanto gasta? Siempre que acelera gasta según lo siguiente: marcha->gasto: 1->5, 2->4, 3->3, 4->2, 5->1. Gasto se multiplica por factorGasto
            - cambia marcha: establece la marcha en la que va: incrementaMarcha, decrementaMarcha. Hay que comprobar que no es menor que 0, ni mayor que el numero de marchas.
            - frenar: Devuelve la velocidad a la que va, (-variacionVelocidad) cada vez que se frena, ademas en cada frenado se llama a actualizar el gasto de gasolina
            - parar: Devuelve true al parar. Tiene sentido si esta moviéndose. El proceso sería Llamar a frenar hasta que la  velocidad =0, y establece marcha 0.
    </section>
    <section data-markdown>
        ## Métodos y propiedades de clase (RA2.e)
        - Similar a los métodos estáticos en Java, un `companion object` no está asociado con una instancia de clase, sino con la propia clase.

        ~~~
        class Persona private constructor(var nombre: String, var apellido: String) {
        // Podemos omitir el nombre del objeto
        companion object {
            var count: Int = 0
            fun create(nombre: String, apellido: String): Person = Person(nombre, apellido)

            // Podemos tener bloques 'init' dentro de un 'companion object'
            init
                { println("Persona companion object created") }
            }
        }
        val persona = Persona.create("John", "Doe")
        ~~~

    </section>
    <section data-markdown>
        ## Métodos y propiedades de clase (RA2.e)
        - ***Actividad 3.6:*** Añade un método de clase, a la clase coche que compare la velocidad de 2 objetos coche.
    </section>
    <section data-markdown>
        *********************
    </section>
    <section data-markdown>
        *********************
    </section>


</section>
