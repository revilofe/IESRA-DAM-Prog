<section>
    <section data-markdown>
        # Unidad 3
        ## Introducción a la programación orientada a objetos
    </section>
    <!--
        Bloques de diapositivas
    -->
    <section data-markdown>
        ## Resultado de Aprendizaje 2
        > Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programación orientada a objetos.
    </section>
    <section data-markdown>
        ## Criterios de evaluación
        - a) Se han identificado los fundamentos de la programación orientada a objetos.
        - b) Se han escrito programas simples.
        - c) Se han instanciado objetos a partir de clases predefinidas.
        - d) Se han utilizado métodos y propiedades de los objetos.
        - e) Se han escrito llamadas a métodos estáticos.
        - f) Se han utilizado parámetros en la llamada a métodos.
        - g) Se han incorporado y utilizado librerías de objetos.
        - h) Se han utilizado constructores.
        - i) Se ha utilizado el entorno integrado de desarrollo en la creación y compilación de programas simples
    </section>

    <section data-markdown>
        ## Contenidos mínimos:
        **Utilización de objetos:**
        - Características de los objetos.
        - Instanciación de objetos.
        - Utilización de métodos.
        - Utilización de propiedades.
        - Utilización de métodos estáticos.
        - Librerías de objetos. Inclusión y uso.
        - Constructores.
        - Destrucción de objetos y liberación de memoria.
        - Entornos de desarrollo para programación orientada a objetos.
            - Entornos específicos.
            - Plugins de integración en entornos genéricos.
    </section>
    <section data-markdown>
        *********************
    </section>
    <section data-markdown>
        ## Programación OO (RA2.a)
        - La [**Programación Orientada a Objetos (POO)**](https://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos):  viene a cambiar la forma de programar. Los objetos se utilizan como metáfora para emular las entidades reales del negocio a modelar.
        - Está basada en varias técnicas como: herencia, cohesión, abstracción, polimorfismo, acoplamiento y encapsulamiento.

        [mapa mental](https://www.mindomo.com/no/mindmap/programacion-orientada-a-objetos-e256c81f6f8fd0e0654dd70bf05ff657)
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        - **Clases:** Una plantilla para la creación de objetos de datos según un modelo predefinido.
        - Ej: Persona, Animal, Coche
        - Las [**clases**](shorturl.at/ikBI9) tienen los siguientes componentes siguientes características, son:
            - **Atributos/campos**: también variables de instancia, contienen la información de los futuros objetos. Normalmente privadas al objeto.
            - **Métodos**: implementan la funcionalidad asociada al objeto, son funciones. Pueden acceder a las variables de instancia de la clase directamente.
            - Cuando se desea realizar una acción sobre un objeto, se dice que se le manda un **mensaje** invocando a un método que realizará la acción.
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        ![](images/clase.png)
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        - **Objetos**: Una instancia de la clase, es decir una concreción. Es un ejemplo de esa clase.
        - Ej: Eduardo, mi perro Tobi, mi coche Ford Fiesta rojo.
        - Los [**objetos**](shorturl.at/gyACE) tienen las siguientes características, son:
            - **Identidad**: Lo identifica del resto.
            - **Comportamiento**: Relacionadlo con su funcionalidad, determina las operaciones que se pueden realizar y con las que responde a los mensajes.
            - **Estado**: Conjunto de atributos y sus valores en un momento determinado.
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        ![](images/objetos.png)
    </section>
    <section data-markdown>
        ## Clases y objetos (RA2.a)
        ![](images/homerpoo.png)
    </section>
    <section data-markdown>
        ## Clases y objetos. En kotlin  (RA2.c)
        - En Kotlin, todo es un objeto en el sentido de que podemos llamar funciones y propiedades de miembro en cualquier variable.
            - `Int` es una clase y `1` es un objeto de la clase `Int`.

        - Clases predefinidas en Kotlin
            - https://kotlinlang.org/api/latest/jvm/stdlib/alltypes/
        - ***Actividad 3.1:*** Crea un programa en el que uses algún metodo de la clase Int y sacalo por consola. Haz lo mismo con otra Clase p.Ej: Pair,
    </section>
    <section data-markdown>
        ## Clases y objetos. En kotlin  (RA2.a)
        - Las clases son los bloques de construcción principales de cualquier lenguaje de programación orientado a objetos.
        - Las clases son esencialmente tipos personalizados: un grupo de variables y métodos unidos en una estructura coherente.
        - Para definir una clase se usa la palabra clave `class`.

        ~~~
            class Perro { ... }
            class Empty // Clase vacia
        ~~~
    </section>
    <section data-markdown>
        ## Clases y objetos. En kotlin (RA2.a)
        En kotlin, las clases pueden contener:
        - Constructores y bloques `init`
        - Métodos(Funciones)
        - Atributos
    </section>

    <section data-markdown>
        ## Constructores (RA2.a)
        - Una clase en Kotlin puede tener un constructor primario y uno o más constructores secundarios.
            - **Primario**: forma parte del encabezado de la clase.
                - Por defecto, todos los constructores son públicos. Visible donde sea visible la clase.
                - Si el constructor principal no tiene anotaciones o modificadores de visibilidad, la palabra clave `constructor` se puede omitir.
                - Este constructor no tiene código, pero se coloca en bloques de inicialización con la palabra clave `init`

        ~~~
            class Persona constructor(nombre: String) { ... } //Crea una clase
            p = Persona("Jose")  //Instancia un objeto de la clase Persona,
        ~~~
    </section>
    <section data-markdown>
        ## Constructores e init (RA2.a)
        - ***Actividad 3.2:*** Copia y ejecuta el siguiente código. ¿Cómo se crea una instancia de la clase? Create una instancia de clase InitOrderDemo ¿Cuál es el orden de ejecución del código?

        ~~~
        class InitOrderDemo(name: String) {
            val firstProperty = "First property: $name"
            init
            {   println("First initializer block that prints ${name}")
            }

            val secondProperty = "Second property: ${name.length}"
            init
            {   println("Second initializer block that prints ${name.length}")
            }
        }
        ~~~
    </section>
    <section data-markdown>
        ## Constructores e init (RA2.a)
        - Dentro de los bloques `init` puedes usar la palabra `required` para validar las propiedades o parámetros.

        ~~~
        class Persona(Nombre: String)
        {
            init
            {   require(nombre.trim().length > 0) { "Argumento nombre inválido." }
            }
        }
        ~~~

        - ***Actividad 3.3:*** Crea una clase coche, que se inicializa con su marca. Ademas y compruebe mediante `require` en el bloque `init` que el argumento marca no es nulo.
    </section>
    <section data-markdown>
        ## Constructores y propiedades (RA2.a)
        - Las variables de  instancia o propiedades pueden definirse en el constructor o en el cuerpo de la clase. Si en el constructor principal usamos:
            - val: Se crearán métodos getter
            - var: Se crearán métodos getter y setter
        - También puedes definirlos tu:

        ~~~
        var stringRepresentation: String
            get() = this.toString()
            // parses the string and assigns values to other properties
            set(value)
            {   setDataFromString(value)
            }
        ~~~
    </section>
    <section data-markdown>
        ## Constructores secundarios (RA2.a)
        - **Secundario**: puede tener uno o varios, y se definen con la palabra clave `constructor`
        - Este constructor tiene código, pero se coloca en bloques de inicialización con la palabra clave `init`
        - Si la clase tiene un constructor primario, el secundario debe delegar en el constructor primario, ya sea directamente o indirectamente usando la palabra clave 'this':

        ~~~
        class Persona(Nombre: String){
            // Constructor secundario, Usamos 'this' para invocar al primario
            constructor(nombre: String, parent: Person) : this(nombre)
            {   parent.children.add(this)
            }
        }
        ~~~
    </section>
    <section data-markdown>
        ## Constructores (RA2.b, c)
        - ***Actividad 3.4:*** Un coche tiene:
        - como atributos en su constructor secundario: Marca, Modelo, velocidadMax y color (por defecto blanco)
        - Crea una clase coche, y compruebe mediante `require` en el bloque `init` que
        - la velocidad es mayor que 10 y menor que 250.
    </section>
    <section data-markdown>
        ## Propiedades (RA2.a)
        - En Kotlin, los campos de la clase se llaman **propiedades** o **variables de instancia**
        - Las propiedades de una clase pueden declararse como mutables (var), o de inmutables o de sólo lectura (val)
        - Se acceden a las propiedades a traves del `.` y el nombre de la propiedad

        ~~~Kt
        class Persona {
            var ciudad: String
            var fechanacimiento: Date
            var codigoPostal: String =
        }
        p=Persona()
        println("La ciudad de la persona es es:$p.ciudad")
        ~~~
    </section>
    <section data-markdown>
        ## Métodos (RA2.a)
        - En Kotlin, las funciones definidas dentro de una clase se llaman funciones miembro o métodos de instancia.
        ~~~
        class Persona {
            var ciudad: String
            fun soyDe():String = "Soy de $ciudad"
        }
        p=Persona()
        println("De donde eres? La ciudad de la persona es es:$p.soyDe()")
        ~~~
    </section>
    <section data-markdown>
        ## Métodos (RA2.b, c)
        - ***Actividad 3.5:*** Un coche tiene:
        - como atributos: Marca, Modelo, #gasolina, Color (defecto blanco), #tanque, #incrementoVelocidad=5, #decrementoVelocidad=5, #velocidadMax
        - como acciones: encender, apagar, iniciar, parar, acelerar, frenar, incrementaMarcha, decrementaMarcha, llenarTanque
        - ademas podremos preguntarle por la descripción del coche, el estado, la marcha actual, la velicidad actual
        - Crea una clase coche, y compruebe mediante `require` en el bloque `init` que
            - el argumento marca no es nulo.
            - la velocidad es mayor que 10 y menor que 250.
    </section>
    <section data-markdown>
        ## Métodos (RA2.b, c)
        - ***Actividad 3.5:*** Un coche tiene (continuación)
        - encender: Devuelve true si enciende. Solo enciende si no esta encendido, tiene marcha metida y tiene gasolina
        - apagar: Vuelve al estado inicial ¿necesitas alguna propiedad o método adicional?
        - iniciar: Solo inicia si esta encendido (No andando), establece marcha 1 y llama a cocheacelerar.
        - acelerar: Devuelve la velocidad a la que va, solo acelera (+5 Velocidad) si tiene gasolina, si no envía mensaje y llama al método parar. No puede superar velocidadMax.
            - cuanto gasta? marcha->gasto: 1->5, 2->4, 3->4, 4->5, 5->1
        - cambia marcha: establece la marcha en la que va: incrementaMarcha, decrementaMarcha
        - frenar: Devuelve la velocidad a la que va, (-5 Velocidad) cada vez que se frena
        - parar: Devuelve true al parar, tiene sentido y esta moviéndose. Llama a frenar hasta velocidad =0, y establece marcha 0.
    </section>

    <section data-markdown>
        ## Métodos y propiedades de clase (RA2.e)
        - Similar a los métodos estáticos en Java, un `companion object` no está asociado con una instancia de clase, sino con la propia clase.
        - La propiedades y métodos se llaman haciendo uso de la clase.

        ~~~
        class Persona private constructor(var nombre: String, var apellido: String) {
        // Podemos omitir el nombre del objeto
        companion object
        {   var count: Int = 0
            fun create(nombre: String, apellido: String): Person = Person(nombre, apellido)

            // Podemos tener bloques 'init' dentro de un 'companion object'
            init
                { println("Persona companion object created") }
            }
        }
        val persona = Persona.create("John", "Doe")
        ~~~

    </section>
    <section data-markdown>
        ## Métodos y propiedades de clase (RA2.e)
        - ***Actividad 3.6:*** Añade un metodo de clase, a la clase coche que compare la velocidad de 2 objetos coche.
    </section>
    <section data-markdown>
        *********************
    </section>
    <section data-markdown>
        *********************
    </section>


</section>
