<script src="https://unpkg.com/kotlin-playground@1" data-selector="code"></script>

<section>
    <section data-markdown>
        # Unidad 6
        ## Creación de programas haciendo uso de características avanzadas de la POO: Herencia y polimorfismo
    </section>
    <!--
        Bloques de diapositivas
    -->
    <section data-markdown>
        ## Resultado de Aprendizaje 7

        > Desarrolla programas aplicando características avanzadas de los lenguajes orientados a objetos y del entorno de programación.

    </section>
    <section data-markdown>
        ## Criterios de evaluación

        - a) Se han identificado los conceptos de herencia, superclase y subclase.
        - b) Se han utilizado modificadores para bloquear y forzar la herencia de clases y métodos.
        - c) Se ha reconocido la incidencia de los constructores en la herencia.
        - d) Se han creado clases heredadas que sobrescriban la implementación de métodos de la superclase.
        - e) Se han diseñado y aplicado jerarquías de clases.
        - f) Se han probado y depurado las jerarquías de clases.
        - g) Se han realizado programas que implementen y utilicen jerarquías de clases.
        - h) Se ha comentado y documentado el código.

    </section>
    <section data-markdown>
        ## Contenidos mínimos:

        **Utilización avanzada de clases:**
        - Composición de clases.
        - Herencia.
        - Superclases y subclases.
        - Clases y métodos abstractos y finales.
        - Sobreescritura de métodos.
        - Constructores y herencia.
    </section>

    <section data-markdown>
        *********************
    </section>

    <!--
        Bloques de diapositivas
    -->

    <section data-markdown>
        ## herencia, superclase, subclase. (RA7.a)

        > ¿Como identificamos los conceptos de herencia, superclase y subclase?

        - Ya vimos en que consistía la herencia, las superclases y las subclases:
        - ![left](images/link.png) [Herencia](https://revilofe.github.io/IESRA-DAM-Prog/#/5/5)

    </section>
    <section data-markdown>
        ## herencia, superclase, subclase. (RA7.a)

        - Existen varias funcionalidades que se le puede dar a la herencia:
        1. **Especialización (es un)**: Se crea una estructura de clases en la que una especializa a la otra `Cuadrado
        -> Figura`
            - `Figura` tiene un comportamiento básico, pero cuadrado lo especializa según sus características.
        2. **Extensión (extiende funcionalidad heredada)**: Se crea estructura en la que una clase extiende el
        comportamiento de otra sin que sea necesariamente un concepto mas especifico `ListaSalvable -> Lista`
            - `Lista` tiene un comportamiento completo funcional, `ListaSalvable` lo extiende añadiendo funcionalidad adicional.
    </section>
    <section data-markdown>
        ## herencia, superclase, subclase. (RA7.a)

        - Existen varias funcionalidades que se le puede dar a la herencia:
        3. **Especificación (define interface)**: Se crea una estructura en la que la superclase especifica la interface
        de sus descendientes. `Texto, Linea, Figura -> ObjetoGrafico`
            - `ObjetoGráfico` especifica como trabajar con objetos gráficos, los descendientes pueden implementar los detalles.
        4. **Construcción (Usado para construir la subbase)**: La hija puede aprovechar la padre pero no tienen conexión. `Pila -> Lista`
            - la clase `Lista` contribuye a crear una `Pila` a través de la herencia.

    </section>
    <section data-markdown>
        ## herencia, superclase, subclase. (RA7.a)

        - ***Actividad individual evaluable:***
        [6.1 De los 4 tipos vistos, pon ejemplo de 2](https://educacionadistancia.juntadeandalucia.es/centros/cadiz/mod/assign/view.php?id=436534)
    </section>
    <section data-markdown>
        ## Clases Abstractas, Interfaces (RA7.b)

        > ¿Como bloqueamos o forzamos la herencia en métodos y clases?

        - Con las **clases abstractas** y las **interfaces** forzamos la herencia (Ten en cuenta que la "herencia" a través de la interfaces no exactamente herencia)
        - Con `open` abrimos una clase y un método para poder heredar de la clase y sobreescribirlo el método.
        - Con `final` se puede marcar un método para evitar que se sobreescriba.
        - Recuerda
            - [Forzar y bloquear la herencia en clases](https://revilofe.github.io/IESRA-DAM-Prog/#/5/7)
            - [Forzar y bloquear la herencia en métodos](https://revilofe.github.io/IESRA-DAM-Prog/#/5/9)

    </section>
    <section data-markdown>
        ## Clases Abstractas, Interfaces (RA7.b)

        > ¿Como bloqueamos o forzamos la herencia en métodos y clases?

        - Kotlin admite **clases abstractas** al igual que Java.
        - Una clase abstracta es una clase con métodos marcados como abstractos y que por tanto no puede ser
        instanciada.
        - Si una clase tiene uno o varios métodos abstractos es una clase abstracta y se indica con la palabra clave
        `abstract`.
        - La subclase concreta de una clase abstracta ***deberá implementar*** todos los métodos y propiedades definidos en la
        clase abstracta; de lo contrario, también será considerada como una clase abstracta.
    </section> <section data-markdown>
        ## Clases Abstractas, Interfaces (RA7.b)

        - Las clases abstractas pueden contener métodos con implementación por defecto como cualquier otra clase.
        - Las subclases de la clase abstracta pueden sobreescribir la implementación predeterminada de un método pero
        solo si el método tiene el modificador `open`.
        - Los métodos marcados como `abstract` también son `open` por defecto.
        - Las clases abstractas también pueden definir variables de instancia al contrario que pasa con las interfaces.

    </section>
    <section data-markdown>
        ## Clases Abstractas, Interfaces (RA7.b)

        - Ya vimos en que consistían las interfaces
        - ![left](images/link.png) [Interfaces](https://revilofe.github.io/IESRA-DAM-Prog/#/5/16)

        - Diferencias entre `Clases Abstractas` e `Interfaces` :
        - Las interfaces permiten definir comportamiento compartidos, mientras que las clases establecen relación de **es un**
        - Las clases puedes implementar varias interfaces, mientras que solo pueden heredar de una sola clase.
        - Puede contener propiedades abstractas y regulares pero sin campos de respaldo (`field`)
        - Las clases pueden tener constructores, mientras que las interfaces no.
        - Todas los métodos definidos por las interfaces se pueden sobrescribir sin tener que ser marcados con `open`, mientras que en las clases no.
    </section>
    <section data-markdown>
        ## Clases Abstractas, Interfaces (RA7.b)

        - ***Actividad:*** Hereda de `Employee` y crea una clase `Teacher`. ¿Te has visto obligad@ a sobreescribir algún método? ¿Porqué? ¿Piensa dos maneras para evitar que fullName de Teacher no se pueda sobreescribir?

        ~~~Kt

        open class Person {
            open fun fullName(): String { ... }
        }

        abstract class Employee (val firstName: String, val lastName: String): Person() {
            // Variable de instancia en una clase abstracta
            val propFoo: String = "bla bla"

            abstract fun earnings(): Double

            // Podemos tener métodos con implementación por defecto
            override fun fullName(): String {
                return lastName + " " + firstName;
            }
        }

        ~~~
    </section>
    <section data-markdown>
        ## Incidencia de constructores en la herencia (RA7.c)

        - Ya vimos como inciden los constructores en la herencia:
v    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        A la hora de comentar, hay dos escuelas:

        - usar los comentarios para **clarificar lo que quisiste expresar con tu código**
        - **evitarlos al máximo** y que comentar tu código es un mal necesario que sólo denota tu falta de habilidad para no hacer código lo suficientemente claro.

        >¿A cuál de los dos consejos deberías hacerle caso?

     </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - Un sistema **sin documentación** está **incompleto**
            - Para tener **calidad**, necesita tener **documentación**, pero esta tiene que tener sentido: es decir, *información acerca del sistema que comunique cosas como la razón de existir de ciertos módulos, valores y funciones y cómo usarlo*.
            - Si tienes que modificarlo, facilitará la **comprensíón** de lo que los programadores anteriores hicieron o intentarón hacer.
        - Por tanto la documentación es **totalmente necesaria**, ahora, donde la ponemos:
            - Documentos **separados** del código suelen **olvidarse** y no se mantienen.
            - Ponerla lo más **cerca del código**, para eso tenemos los comentarios, **facilitará encontrarlos y mantenerlos**.
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - Puedes usar los comentarios **documentar**:
            - Decisiones de diseño
            - Explicaciones sobre la existencia, funcionamiento o razón de ser de cierta parte del código
            - Las interfaces y su ejemplo de uso
            - Efectos de usar cierto código
            - Partes no finalizadas o que se pueden mejorar (TODO’s)
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - Los comentarios pueden **ayudarte en el futuro**
            - Estarán ahi para recordarte lo que hiciste y por qué.
            - Seguramente tu mente haya borrado información valiosa de por qué una variable tiene un valor de inicio y no otro.
            - Tu yo futuro y tu equipo te agradecerán los comentarios aclaratorios de tomas de decisiones.
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - Los comentarios son una **buena herramienta de diseño**.
            - Existen gurus, como John Ousterhout, en “A Philosophy of Software Design” que recomienda **empezar con los comentarios antes de programar**. Pero, ¿por qué lo recomienda?
            - Escribir en un lenguaje humano cómo funciona algo antes de implementarlo realmente, te da la capacidad de **ver si es lógico y suficiente**, además te permite **ponerte en los zapatos del usuario** para notar deficiencias sobre todo en la interfaz. Los **comentarios de la interfaz es lo primero que deberías crear** porque te servirán de guía para avanzar con tu diseño y, sobre todo, que sea lógico y fácil de usar.
            - Una buena guía: si no eres capaz de crear un comentario **concreto y corto** sobre cómo funciona o por qué existe algo, lo más probable es que **tengas que re-pensar tu diseño**.

    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - **El lenguaje de programación no es suficiente** para expresar todo lo necesario
            - Todos los lenguajes de programación están pensados para ser un subconjunto del lenguaje humano que elimine las ambigüedades, manteniendo el mayor poder expresivo posible. Esto nos lleva a sus limitantes: es **imposible**, o por lo menos impráctico, **intentar expresar todas las ideas con el código**.
            - En la práctica, el tiempo y los recursos para lograr algo son limitados, por lo que a veces es más conveniente y fácil para todos explicar lenguaje humano algo que intentar expresarlo con código, como los puristas afirman.
            - No te sientas mal si tienes que recurrir de vez en cuando a explicar la forma en que funciona algo, siempre y cuando *no sea la práctica común*.

        - ¿Cómo usar los comentarios para que sean valiosos?
            - No todos los comentarios son valiosos, hay **algunos que pueden estorbar** más de lo que ayudan, por ejemplo, los que no aportan información a lo que es obvio en el código.
            - Hablemos de algunas formas de **aprovecharlos lo mejor posible** para que contribuyan positivamente a aumentar la calidad del proyecto.
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - Escribe *los comentarios primero*
            - Una de las partes más importantes de los comentarios como documentación es que **deben ser concretos, cercanos a la realidad y que proporcionen la mayor cantidad de información útil posible**.
            - Para lograr esto, se tienen que **crear lo más cerca que puedas a la creación del código**. Pero como todos sabemos que después de escribir y probar (básicamente) el código vamos a sentir que ya está terminado, es buena práctica obligarte a escribirlos antes, **justo como propone TDD con las pruebas**.
            - De esta manera te asegurarás que tu código esté documentado incluso antes de escribirlo y **te servirán como una herramienta de diseño** que te ayudará a pensar mejor en la usabilidad de tus módulos y piezas de software.
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - **Crea** comentarios **sobre la interfaz**
            - **La interfaz es el medio de uso que tus módulos o funciones presentan** para que las demás partes de tu sistema lo usen.
            - Lo primero que deberías documentar y explicar es esta interfaz, para que más personas a parte de ti puedan usar este pedazo de código.
            - Debes escribir comentarios claros sobre:
            - -> **Cómo usar esa pieza de código**
            - -> **Por qué existe esa parte del sistema**
            - -> **Qué efectos tiene usarla**
            - Este tipo de comentarios son los que aportan mayor valor al sistema y si están lo suficientemente completos, con ejemplos y explicaciones claras, son una documentación válida que está en un muy buen lugar: es fácil de encontrar y no se va a perder enterrada entre otros documentes que después nadie va a consultar.
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - **Evita** los comentarios **sobre la implementación**
            - Los comentarios sobre la implementación son aquello que describen qué estas haciendo, como por ejemplo, sumar número, abrir un archivo, etc.
            - Estos comentarios normalmente **son innecesarios**, ya que lo que se está haciendo es obvio si el código es lo suficientemente expresivo y siempre deberíamos buscar que sea así.
            - De hecho, estos son los comentarios que hacen que la gente odie a los comentarios en general, pues **en vez de proporcionar información extra son una carga que hay que mantener y pueden confundir si no son actualizados**.
            - Si realmente sientes que tienes que explicar qué estás haciendo con cierta pieza de código, primero **pregúntate si no hay una manera de reescribirlo para que sea obvio**.
            - Si no existe o no es práctica esta solución, entonces escribe el comentario de la manera más concisa posible, incluyendo la razón de la existencia de ese código.
            - Para hacer esto debes tomar muy en cuenta los recursos del proyecto: **no te puedes tardar el triple del tiempo** implementando la pieza de código perfecta porque no quieres escribir un comentario que explique cómo funciona.
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        > Escribir comentarios es una de las grandes tareas que los programadores debemos dominar.
        > Los lenguajes de programación y los entornos de programación cada vez le dan más poder a esta parte de los programas y permiten incluso escribir pruebas en ellos, generar documentación automática y listar tareas a partir de ellos.
        > Si pones el suficiente esmero en aprender a escribir buenos comentarios y mantenerlos, serán una gran herramienta de diseño y documentación de tu software.

    </section>

    <section data-markdown>
    ## Se ha comentado y documentado el código (h)

        ### DOKA
        ![left](images/link.png) [Dokka](https://kotlin.github.io/dokka/1.6.10/)
        - **Herramienta que permite genera la documentación**.
        - Configuración básica y mínima: Añade al fichero  `build.gradle.kts:`

        ~~~
        plugins {
            id("org.jetbrains.dokka") version "1.6.10"
        }

        repositories {
            mavenCentral()
        }
        ~~~

        - Ahora en aparecerán nuevas tareas en la pestaña de gradle.

    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        ### KDOC
        ![left](images/link.png) [Sintaxis de KDoc](https://kotlinlang.org/docs/kotlin-doc.html#kdoc-syntax)
        - **Lenguaje que permite documentar**.
        - Documenta la interface de las clases, métodos, propiedades, etc.
        - Para genera la documentación, en las opciones de `Gradle`, busca la tarea `Task->Documentación->DokkaHtml` y púlsala.
        - La documentación se genera en la carpeta `build` de tu proyecto.

    </section>
    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - *** ***
        [6.x Generera la documentación del programa.](https://educacionadistancia.juntadeandalucia.es/centros/cadiz/mod/assign/view.php?id=436534)
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - ***Actividad individual evaluable:***
        [6.4 Comentar y documentar el código (RA7.h)](https://educacionadistancia.juntadeandalucia.es/centros/cadiz/mod/assign/view.php?id=447140)
    </section>

    <section data-markdown>
        ## Se ha comentado y documentado el código (h)

        - ***Actividad individual evaluable:*** Investiga sobre Depedencia, Asociación, Agregación composición.
            - Describe que representa en el código, y para ello usa tambien un ejemplo de código
            - Representa el ejemplo y la relación haciendo uso de UML
        [Ejemplo](http://alumnosdc.blogspot.com/2013/05/agregacion-composicion-y-dependencia.html)

    </section>

    <section data-markdown>
        ## Principio de inversión de dependencias (RA7.)

        - Básicamente lo que nos dice este principio es que:
            - Las clases de alto nivel no deberían depender de las clases de bajo nivel. Ambas deberían depender de las abstracciones.
            - Las abstracciones no deberían depender de los detalles. Los detalles deberían depender de las abstracciones.
    </section>

    <section data-markdown>
        ## Principio de inversión de dependencias (RA7.)
        - En Informática, **Inyección de Dependencias** (en inglés Dependency Injection, DI) es un patrón de diseño
        orientado a objetos, en el que **se suministran objetos a una clase** en lugar de ser la propia clase quien cree
        el objeto.
        - Es una herramienta comúnmente utilizada en varios patrones de diseño orientado a objetos, consiste en inyectar
        comportamientos a componentes.
        - El término fue acuñado por primera vez por *Martin Fowler*.
    </section>

    <section data-markdown>
        ## Principio de inversión de dependencias (RA7.)
        - Esto no es más que extraer responsabilidades a un componente para delegarlas en otro, estableciendo un
        mecanismo a través del cual el nuevo componente pueda ser cambiado en tiempo de ejecución.
        - Es conveniente no confundir **Inversión de dependencias (DIP)** con **Inversión de Control (IoC)**.
            - Inyección de dependencias (Patrón de diseño):  Las abstraciones nunca deben depender de los detalles.
            - Inversión de dependencias (Principio DIP de SOLID)

    </section>
    <section data-markdown>
        ## Principio de inversión de dependencias (RA7.)
        - Cumplir con el DIP hace que el código de la lógica de negocio de tu aplicación no dependa de los detalles de implementación, si no de abstracciones. Esto hará que en el futuro puedas cambiar los detalles de implementación sin tener que modificar el código de tu lógica de negocio.
        - [Ejemplo](https://github.com/revilofe/IESRA-DAM-Prog/blob/master/ejercicios/src/main/kotlin/un6/dip/dip.md)
    </section>

    <!--

        <section data-markdown>
            https://programmerclick.com/article/7789294027/
            http://joaquin.medina.name/web2008/documentos/informatica/documentacion/logica/OOP/Principios/Oop_Solid_DIP/2012_09_14_DependencyInversionPrincipe.html
            https://devexperto.com/principio-de-inversion-de-dependencias/
        </section>
        <section data-markdown>

        </section>
        <section data-markdown>

        </section>

        <section data-markdown>

        </section>
        <section data-markdown>
            ## In
            - En

            - ***Actividad:*** Mo

            ~~~Kt
                interface A {

            ~~~
        </section>

        <section data-markdown>
            ##

        </section>
-->
        <section data-markdown>

<div class="kotlin-code">
class Contact(val id: Int, var email: String)

fun main(args: Array<String>) {
    val contact = Contact(1, "mary@gmail.com")
    println(contact.id)
}
</div>

        </section>
    <section data-markdown>
        ## BIBLIOGRAFÍA
        - ![left](images/link.png) [https://kotlinlang.org/](https://kotlinlang.org)
        - ![left](images/link.png) [Apuntes de kotlin](https://github.com/revilofe/_kotlin_)
        - ![left](images/link.png) [Clases abstractas, interfaces, herencia] (https://code.tutsplus.com/es/tutorials/kotlin-from-scratch-abstract-classes-interfaces-inheritance-and-type-alias--cms-29744)
        - ![left](images/link.png) [Clases abstractas] (https://www.develou.com/clases-abstractas-en-kotlin/)
        - ![left](images/link.png) [Herencia en kotlin](https://www.develou.com/herencia-en-kotlin/)
        - ![left](images/link.png) [Interfaces en kotlin I](https://www.develou.com/interfaces-en-kotlin/)
        - ![left](images/link.png) [Interfaces en kotlin II](https://devexperto.com/interfaces-kotlin/)
        - ![left](images/link.png) [https://kotlinlang.org/](https://kotlinlang.org)
        - ![left](images/link.png) [Deberías comentar tu código]([)https://blog.thedojo.mx/2020/12/30/deberias-comentar-tu-codigo.html)
           - Head First Kotlin, A Brain-Friendly Guide; Dawn Griffiths & David Griffiths; 2019 - O'Reilly Media
           - A Philosophy of Software Design, John Ousterhout. (Le dedica 4 capítulos a buen uso de los comentarios)
       </section>


      </section>






